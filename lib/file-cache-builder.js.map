{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/file-cache-builder.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\nGUY                       = require 'guy'\n{ alert\n  debug\n  help\n  info\n  plain\n  praise\n  urge\n  warn\n  whisper }               = GUY.trm.get_loggers 'promptparser/file-cache-builder'\n{ rpr\n  inspect\n  echo\n  reverse\n  log     }               = GUY.trm\nFS                        = require 'node:fs'\nCRYPTO                    = require 'node:crypto'\n{ DBay }                  = require 'dbay'\n{ SQL  }                  = DBay\nnosuchprompt              = \"\"\n\n#-----------------------------------------------------------------------------------------------------------\nid_from_text = ( text, length = 8 ) ->\n  hash = CRYPTO.createHash 'sha1'\n  hash.update text\n  return ( hash.digest 'hex' )[ ... length ]\n\n#-----------------------------------------------------------------------------------------------------------\nset_path = ->\n  process.chdir path if ( path = process.argv[ 2 ] ? null )?\n  R = process.cwd()\n  info \"Ω___1 CWD: #{R}\"\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\ndemo_exifreader = ->\n  PATH            = require 'node:path'\n  { glob\n    globSync  }   = require 'glob'\n  ExifReader      = require 'exifreader'\n  patterns        = [ '**/*.png', '**/*.jpg', ]\n  cfg             = { dot: true }\n  base_path       = set_path()\n  count           = 0\n  DB              = prepare_db()\n  #.........................................................................................................\n  exif_from_path  = do =>\n    my_buffer = new Buffer.alloc 2 * 1024\n    return ( path ) ->\n      fd          = FS.openSync path\n      FS.readSync fd, my_buffer\n      exif        = ExifReader.load my_buffer\n      if ( data = exif?.UserComment ? null )?\n        R = JSON.parse ( Buffer.from data.value ).toString 'utf-8'\n      else\n        R = { prompt: nosuchprompt, date: null, }\n      #.....................................................................................................\n      R.prompt_id = id_from_text R.prompt\n      return R\n  #.........................................................................................................\n  do =>\n    DB.db ->\n      console.time 'demo_exifreader'\n      counts    =\n        skipped:  0\n        added:    0\n        deleted:  0\n      rel_paths = globSync patterns, cfg\n      info 'Ω__17', \"found #{rel_paths.length} matching files\"\n      for rel_path in rel_paths\n        count++; whisper count if ( count %% 1000 ) is 0\n        break if count > 10000 ### !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ###\n        abs_path  = PATH.resolve base_path, rel_path\n        path_id   = id_from_text abs_path\n        #...................................................................................................\n        if DB.known_path_ids.has path_id\n          # help \"Ω__18 skipping path ID #{rpr path_id}\"\n          counts.skipped++\n          ### NOTE we know that in the present run we will not again have to test against the current\n          `path_id`, so we also know we can safely delete it from the pool of known IDs (thereby making it\n          smaller and potentially a tad faster); after having gone through all `path_ids` in the file\n          system, we will then effectively have turned `DB.known_path_ids` into `extraneous_path_ids`, i.e.\n          those that could be deleted from the DB if deemed necessary. ###\n          DB.known_path_ids.delete path_id\n        else\n          # warn \"Ω__19 inserting path ID #{rpr path_id}\"\n          counts.added++\n          #.................................................................................................\n          exif = exif_from_path abs_path\n          ### TAINT use prepared statement ###\n          DB.db SQL\"\"\"\n            insert into prompts ( id, prompt ) values ( ?, ? )\n              on conflict ( id ) do nothing;\"\"\", [\n            exif.prompt_id, exif.prompt, ]\n          ### TAINT use prepared statement ###\n          DB.db SQL\"\"\"insert into files ( id, prompt_id, path ) values ( ?, ?, ? );\"\"\", [\n            path_id, exif.prompt_id, abs_path, ]\n      #.....................................................................................................\n      info \"Ω__21 changes to DB at #{DB.path}: #{rpr counts}\"\n      #.....................................................................................................\n      return null\n    console.timeEnd 'demo_exifreader'\n    return null\n  #.........................................................................................................\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nprepare_db = ->\n  path                = '/dev/shm/files-and-prompts.sqlite'\n  db                  = new DBay { path, }\n  #.........................................................................................................\n  get_must_initialize = ( db ) ->\n    tables    = db.first_values SQL\"select name from sqlite_schema where type = 'table' order by name;\"\n    tables    = [ tables..., ]\n    R         = false\n    R       or= 'files'    not in tables\n    R       or= 'prompts'  not in tables\n    return R\n  #.........................................................................................................\n  initialize_db = ( db ) ->\n    db ->\n      db SQL\"drop table if exists files;\"\n      db SQL\"drop table if exists prompts;\"\n      db SQL\"\"\"\n        create table files (\n            id        text not null primary key,\n            prompt_id text not null,\n            path      text not null,\n          foreign key ( prompt_id ) references prompts ( id ) );\"\"\"\n      db SQL\"\"\"\n        create table prompts (\n          id      text not null primary key,\n          prompt  text not null );\"\"\"\n      db SQL\"\"\"insert into prompts ( id, prompt ) values ( ?, ? );\"\"\", [\n        ( id_from_text nosuchprompt ), nosuchprompt, ]\n      return null\n    return null\n  #.........................................................................................................\n  if get_must_initialize db\n    warn \"Ω__22 initializing DB at #{path}\"\n    initialize_db db\n  else\n    help \"Ω__23 re-using DB at #{path}\"\n  #.........................................................................................................\n  ### TAINT can we use an API call to get a set? ###\n  known_path_ids = do =>\n    R = new Set()\n    R.add id for id from db.first_values SQL\"select * from files;\"\n    return R\n  #.........................................................................................................\n  return { path, db, known_path_ids, }\n\n\n#===========================================================================================================\nif module is require.main then await do =>\n  # await demo_fast_glob()\n  # await demo_node_glob()\n  # await demo_exifr()\n  # await demo_exiftool_vendored()\n  await demo_exifreader()\n  # demo_dbay_with_exifdata()\n"
  ]
}